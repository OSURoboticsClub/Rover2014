
ArmControl.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000033e  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000014  00802000  0000033e  000003d2  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000001  00802014  00802014  000003e6  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  000003e6  2**0
                  CONTENTS, READONLY
  4 .debug_aranges 00000020  00000000  00000000  00000416  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00000550  00000000  00000000  00000436  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 000001bc  00000000  00000000  00000986  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   0000020a  00000000  00000000  00000b42  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000034  00000000  00000000  00000d4c  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    000004d5  00000000  00000000  00000d80  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000000a3  00000000  00000000  00001255  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000010  00000000  00000000  000012f8  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
   0:	0c 94 b6 00 	jmp	0x16c	; 0x16c <__ctors_end>
   4:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
   8:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
   c:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  10:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  14:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  18:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  1c:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  20:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  24:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  28:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  2c:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  30:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  34:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  38:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  3c:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  40:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  44:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  48:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  4c:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  50:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  54:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  58:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  5c:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  60:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  64:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  68:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  6c:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  70:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  74:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  78:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  7c:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  80:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  84:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  88:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  8c:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  90:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  94:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  98:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  9c:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  a0:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  a4:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  a8:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  ac:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  b0:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  b4:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  b8:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  bc:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  c0:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  c4:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  c8:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  cc:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  d0:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  d4:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  d8:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  dc:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  e0:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  e4:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  e8:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  ec:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  f0:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  f4:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  f8:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
  fc:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
 100:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
 104:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
 108:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
 10c:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
 110:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
 114:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
 118:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
 11c:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
 120:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
 124:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
 128:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
 12c:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
 130:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
 134:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
 138:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
 13c:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
 140:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
 144:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
 148:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
 14c:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
 150:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
 154:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
 158:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
 15c:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
 160:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
 164:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>
 168:	0c 94 d3 00 	jmp	0x1a6	; 0x1a6 <__bad_interrupt>

0000016c <__ctors_end>:
 16c:	11 24       	eor	r1, r1
 16e:	1f be       	out	0x3f, r1	; 63
 170:	cf ef       	ldi	r28, 0xFF	; 255
 172:	cd bf       	out	0x3d, r28	; 61
 174:	df e2       	ldi	r29, 0x2F	; 47
 176:	de bf       	out	0x3e, r29	; 62

00000178 <__do_copy_data>:
 178:	10 e2       	ldi	r17, 0x20	; 32
 17a:	a0 e0       	ldi	r26, 0x00	; 0
 17c:	b0 e2       	ldi	r27, 0x20	; 32
 17e:	ee e3       	ldi	r30, 0x3E	; 62
 180:	f3 e0       	ldi	r31, 0x03	; 3
 182:	02 c0       	rjmp	.+4      	; 0x188 <__do_copy_data+0x10>
 184:	05 90       	lpm	r0, Z+
 186:	0d 92       	st	X+, r0
 188:	a4 31       	cpi	r26, 0x14	; 20
 18a:	b1 07       	cpc	r27, r17
 18c:	d9 f7       	brne	.-10     	; 0x184 <__do_copy_data+0xc>

0000018e <__do_clear_bss>:
 18e:	20 e2       	ldi	r18, 0x20	; 32
 190:	a4 e1       	ldi	r26, 0x14	; 20
 192:	b0 e2       	ldi	r27, 0x20	; 32
 194:	01 c0       	rjmp	.+2      	; 0x198 <.do_clear_bss_start>

00000196 <.do_clear_bss_loop>:
 196:	1d 92       	st	X+, r1

00000198 <.do_clear_bss_start>:
 198:	a5 31       	cpi	r26, 0x15	; 21
 19a:	b2 07       	cpc	r27, r18
 19c:	e1 f7       	brne	.-8      	; 0x196 <.do_clear_bss_loop>
 19e:	0e 94 d5 00 	call	0x1aa	; 0x1aa <main>
 1a2:	0c 94 9d 01 	jmp	0x33a	; 0x33a <_exit>

000001a6 <__bad_interrupt>:
 1a6:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000001aa <main>:
/*! Success variable, used to test driver. */
bool success;


int main(void)
{
 1aa:	cf 93       	push	r28
 1ac:	df 93       	push	r29
 1ae:	cd b7       	in	r28, 0x3d	; 61
 1b0:	de b7       	in	r29, 0x3e	; 62
 1b2:	63 97       	sbiw	r28, 0x13	; 19
 1b4:	cd bf       	out	0x3d, r28	; 61
 1b6:	de bf       	out	0x3e, r29	; 62
	
	CCP = CCP_IOREG_gc;              // disable register security for oscillator update
 1b8:	88 ed       	ldi	r24, 0xD8	; 216
 1ba:	84 bf       	out	0x34, r24	; 52
	OSC.CTRL = OSC_RC32MEN_bm;       // enable 32MHz oscillator
 1bc:	82 e0       	ldi	r24, 0x02	; 2
 1be:	80 93 50 00 	sts	0x0050, r24
	while(!(OSC.STATUS & OSC_RC32MRDY_bm)); // wait for oscillator to be ready
 1c2:	e0 e5       	ldi	r30, 0x50	; 80
 1c4:	f0 e0       	ldi	r31, 0x00	; 0
 1c6:	81 81       	ldd	r24, Z+1	; 0x01
 1c8:	81 ff       	sbrs	r24, 1
 1ca:	fd cf       	rjmp	.-6      	; 0x1c6 <main+0x1c>
	CCP = CCP_IOREG_gc;              // disable register security for clock update
 1cc:	88 ed       	ldi	r24, 0xD8	; 216
 1ce:	84 bf       	out	0x34, r24	; 52
	CLK.CTRL = CLK_SCLKSEL_RC32M_gc; // switch to 32MHz clock
 1d0:	21 e0       	ldi	r18, 0x01	; 1
 1d2:	20 93 40 00 	sts	0x0040, r18
	
	/* Variable used to send and receive data. */
	uint8_t sendData[] = "This is a string\r\n";
 1d6:	83 e1       	ldi	r24, 0x13	; 19
 1d8:	e0 e0       	ldi	r30, 0x00	; 0
 1da:	f0 e2       	ldi	r31, 0x20	; 32
 1dc:	de 01       	movw	r26, r28
 1de:	11 96       	adiw	r26, 0x01	; 1
 1e0:	01 90       	ld	r0, Z+
 1e2:	0d 92       	st	X+, r0
 1e4:	8a 95       	dec	r24
 1e6:	e1 f7       	brne	.-8      	; 0x1e0 <main+0x36>
	//uint8_t receivedData;

	/* This PORT setting is only valid to USARTC0 if other USARTs is used a
	 * different PORT and/or pins is used. */
	/* PIN3 (TXD0) as output. */
	PORTC.DIRSET = PIN3_bm;
 1e8:	a0 e4       	ldi	r26, 0x40	; 64
 1ea:	b6 e0       	ldi	r27, 0x06	; 6
 1ec:	88 e0       	ldi	r24, 0x08	; 8
 1ee:	11 96       	adiw	r26, 0x01	; 1
 1f0:	8c 93       	st	X, r24
 1f2:	11 97       	sbiw	r26, 0x01	; 1

	/* PC2 (RXD0) as input. */
	PORTC.DIRCLR = PIN2_bm;
 1f4:	34 e0       	ldi	r19, 0x04	; 4
 1f6:	12 96       	adiw	r26, 0x02	; 2
 1f8:	3c 93       	st	X, r19
 1fa:	12 97       	sbiw	r26, 0x02	; 2

	/* USARTC0, 8 Data bits, No Parity, 1 Stop bit. */
	USART_Format_Set(&USART, USART_CHSIZE_8BIT_gc, USART_PMODE_DISABLED_gc, false);
 1fc:	e0 ea       	ldi	r30, 0xA0	; 160
 1fe:	f8 e0       	ldi	r31, 0x08	; 8
 200:	83 e0       	ldi	r24, 0x03	; 3
 202:	85 83       	std	Z+5, r24	; 0x05
	 * Do not use the baudrate scale factor
	 *
	 * Baudrate select = (1/(16*(((I/O clock frequency)/Baudrate)-1)
	 *                 = 12
	 */
	USART_Baudrate_Set(&USART, 207 , 0);
 204:	8f ec       	ldi	r24, 0xCF	; 207
 206:	86 83       	std	Z+6, r24	; 0x06
 208:	17 82       	std	Z+7, r1	; 0x07

	/* Enable both RX and TX. */
	USART_Rx_Enable(&USART);
 20a:	84 81       	ldd	r24, Z+4	; 0x04
 20c:	80 61       	ori	r24, 0x10	; 16
 20e:	84 83       	std	Z+4, r24	; 0x04
	USART_Tx_Enable(&USART);
 210:	84 81       	ldd	r24, Z+4	; 0x04
 212:	88 60       	ori	r24, 0x08	; 8
 214:	84 83       	std	Z+4, r24	; 0x04


	/* Assume that everything is OK. */
	success = true;
 216:	20 93 14 20 	sts	0x2014, r18
	/* Send data from 255 down to 0*/
	
	//Setup Status and Error LEDS
	PORTC.DIRSET = (PIN5_bm | PIN6_bm | PIN7_bm);
 21a:	80 ee       	ldi	r24, 0xE0	; 224
 21c:	11 96       	adiw	r26, 0x01	; 1
 21e:	8c 93       	st	X, r24
	
	//Setup Outputs
	PORTD.DIRSET = (PIN0_bm | PIN1_bm | PIN2_bm | PIN3_bm | PIN4_bm | PIN5_bm | PIN6_bm | PIN7_bm);
 220:	e0 e6       	ldi	r30, 0x60	; 96
 222:	f6 e0       	ldi	r31, 0x06	; 6
 224:	9f ef       	ldi	r25, 0xFF	; 255
 226:	91 83       	std	Z+1, r25	; 0x01
	PORTA.DIRSET = (PIN5_bm | PIN6_bm | PIN7_bm);  //First set of M settings
 228:	60 e0       	ldi	r22, 0x00	; 0
 22a:	76 e0       	ldi	r23, 0x06	; 6
 22c:	db 01       	movw	r26, r22
 22e:	11 96       	adiw	r26, 0x01	; 1
 230:	8c 93       	st	X, r24
	PORTB.DIRSET = (PIN0_bm | PIN1_bm | PIN2_bm);  //Second set of M settings
 232:	80 e2       	ldi	r24, 0x20	; 32
 234:	96 e0       	ldi	r25, 0x06	; 6
 236:	47 e0       	ldi	r20, 0x07	; 7
 238:	dc 01       	movw	r26, r24
 23a:	11 96       	adiw	r26, 0x01	; 1
 23c:	4c 93       	st	X, r20

	//Setup Inputs
	PORTA.DIRCLR = (PIN2_bm);
 23e:	db 01       	movw	r26, r22
 240:	12 96       	adiw	r26, 0x02	; 2
 242:	3c 93       	st	X, r19
 244:	12 97       	sbiw	r26, 0x02	; 2

	//SETUP "UPPER" DRIVER
	//Set the enable pin low (disable high)
	MD1_DISABLE();
 246:	50 e4       	ldi	r21, 0x40	; 64
 248:	55 83       	std	Z+5, r21	; 0x05
	
	//Setup Microstepping
	MD1_M0_CLR();
 24a:	40 e2       	ldi	r20, 0x20	; 32
 24c:	16 96       	adiw	r26, 0x06	; 6
 24e:	4c 93       	st	X, r20
 250:	16 97       	sbiw	r26, 0x06	; 6
	MD1_M1_CLR();
 252:	16 96       	adiw	r26, 0x06	; 6
 254:	5c 93       	st	X, r21
 256:	16 97       	sbiw	r26, 0x06	; 6
	MD1_M2_CLR();
 258:	50 e8       	ldi	r21, 0x80	; 128
 25a:	16 96       	adiw	r26, 0x06	; 6
 25c:	5c 93       	st	X, r21
	
	MD1_DIR_CLR();
 25e:	50 e1       	ldi	r21, 0x10	; 16
 260:	56 83       	std	Z+6, r21	; 0x06
	MD1_STEP_CLR();
 262:	46 83       	std	Z+6, r20	; 0x06
	
	//Motor Driver 2 setup
	MD2_ENABLE();
 264:	36 83       	std	Z+6, r19	; 0x06
	
	//Setup Microstepping
	MD2_M0_CLR();
 266:	dc 01       	movw	r26, r24
 268:	16 96       	adiw	r26, 0x06	; 6
 26a:	2c 93       	st	X, r18
 26c:	16 97       	sbiw	r26, 0x06	; 6
	MD2_M1_CLR();
 26e:	42 e0       	ldi	r20, 0x02	; 2
 270:	16 96       	adiw	r26, 0x06	; 6
 272:	4c 93       	st	X, r20
 274:	16 97       	sbiw	r26, 0x06	; 6
	MD2_M2_CLR();
 276:	16 96       	adiw	r26, 0x06	; 6
 278:	3c 93       	st	X, r19
	
	MD2_DIR_CLR();
 27a:	26 83       	std	Z+6, r18	; 0x06
	MD2_STEP_CLR();
 27c:	46 83       	std	Z+6, r20	; 0x06
	
	
	int swap = 0;
 27e:	80 e0       	ldi	r24, 0x00	; 0
 280:	90 e0       	ldi	r25, 0x00	; 0
		while(sendData[i] != '\0') {
		    /* Send one char. */
			do{
				/* Wait until it is possible to put data into TX data register.
				 * NOTE: If TXDataRegister never becomes empty this will be a DEADLOCK. */
			}while(!USART_IsTXDataRegisterEmpty(&USART));
 282:	e0 ea       	ldi	r30, 0xA0	; 160
 284:	f8 e0       	ldi	r31, 0x08	; 8
		/* Disable both RX and TX. */


		//PORTC.OUTSET = (PIN5_bm | PIN6_bm | PIN7_bm);
		//PORTD.OUTSET = PIN5_bm;
		MD2_STEP_SET();
 286:	40 e6       	ldi	r20, 0x60	; 96
 288:	56 e0       	ldi	r21, 0x06	; 6
 28a:	68 94       	set
 28c:	ff 24       	eor	r15, r15
 28e:	f1 f8       	bld	r15, 1
			MD2_DIR_SET();
			STATUS1_CLR();
			STATUS2_SET();
		}
		else {
			MD2_DIR_CLR();
 290:	bb 24       	eor	r11, r11
 292:	b3 94       	inc	r11
			STATUS1_SET();
 294:	20 e4       	ldi	r18, 0x40	; 64
 296:	36 e0       	ldi	r19, 0x06	; 6
 298:	68 94       	set
 29a:	cc 24       	eor	r12, r12
 29c:	c6 f8       	bld	r12, 6
			STATUS2_CLR();
 29e:	68 94       	set
 2a0:	dd 24       	eor	r13, r13
 2a2:	d5 f8       	bld	r13, 5
		
		if((PORTA.IN & (1 << PIN0_bp)) == 0){
			ERROR_SET();
		}
		else {
			ERROR_CLR();
 2a4:	68 94       	set
 2a6:	ee 24       	eor	r14, r14
 2a8:	e7 f8       	bld	r14, 7
	
	int swap = 0;
	
	while(1) {
		int i = 0;
		while(sendData[i] != '\0') {
 2aa:	09 81       	ldd	r16, Y+1	; 0x01
 2ac:	00 23       	and	r16, r16
 2ae:	49 f0       	breq	.+18     	; 0x2c2 <main+0x118>
 2b0:	de 01       	movw	r26, r28
 2b2:	12 96       	adiw	r26, 0x02	; 2
		    /* Send one char. */
			do{
				/* Wait until it is possible to put data into TX data register.
				 * NOTE: If TXDataRegister never becomes empty this will be a DEADLOCK. */
			}while(!USART_IsTXDataRegisterEmpty(&USART));
 2b4:	11 81       	ldd	r17, Z+1	; 0x01
	
	while(1) {
		int i = 0;
		while(sendData[i] != '\0') {
		    /* Send one char. */
			do{
 2b6:	15 ff       	sbrs	r17, 5
 2b8:	fd cf       	rjmp	.-6      	; 0x2b4 <main+0x10a>
				/* Wait until it is possible to put data into TX data register.
				 * NOTE: If TXDataRegister never becomes empty this will be a DEADLOCK. */
			}while(!USART_IsTXDataRegisterEmpty(&USART));
			USART_PutChar(&USART, sendData[i]);
 2ba:	00 83       	st	Z, r16
	
	int swap = 0;
	
	while(1) {
		int i = 0;
		while(sendData[i] != '\0') {
 2bc:	0d 91       	ld	r16, X+
 2be:	01 11       	cpse	r16, r1
 2c0:	f9 cf       	rjmp	.-14     	; 0x2b4 <main+0x10a>
		/* Disable both RX and TX. */


		//PORTC.OUTSET = (PIN5_bm | PIN6_bm | PIN7_bm);
		//PORTD.OUTSET = PIN5_bm;
		MD2_STEP_SET();
 2c2:	da 01       	movw	r26, r20
 2c4:	15 96       	adiw	r26, 0x05	; 5
 2c6:	fc 92       	st	X, r15
	#else
		//round up by default
		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
	#endif

	__builtin_avr_delay_cycles(__ticks_dc);
 2c8:	af ed       	ldi	r26, 0xDF	; 223
 2ca:	b1 e0       	ldi	r27, 0x01	; 1
 2cc:	11 97       	sbiw	r26, 0x01	; 1
 2ce:	f1 f7       	brne	.-4      	; 0x2cc <main+0x122>
 2d0:	00 c0       	rjmp	.+0      	; 0x2d2 <main+0x128>
 2d2:	00 00       	nop
		_delay_us(60);
		MD2_STEP_CLR();
 2d4:	da 01       	movw	r26, r20
 2d6:	16 96       	adiw	r26, 0x06	; 6
 2d8:	fc 92       	st	X, r15
 2da:	af ed       	ldi	r26, 0xDF	; 223
 2dc:	b1 e0       	ldi	r27, 0x01	; 1
 2de:	11 97       	sbiw	r26, 0x01	; 1
 2e0:	f1 f7       	brne	.-4      	; 0x2de <main+0x134>
 2e2:	00 c0       	rjmp	.+0      	; 0x2e4 <main+0x13a>
 2e4:	00 00       	nop
		//PORTD.OUTCLR = PIN5_bm;
		//PORTC.OUTCLR = (PIN5_bm | PIN6_bm | PIN7_bm);
		_delay_us(60);
		
		++swap;
 2e6:	01 96       	adiw	r24, 0x01	; 1
		
		if(swap > 250){
 2e8:	8b 3f       	cpi	r24, 0xFB	; 251
 2ea:	91 05       	cpc	r25, r1
 2ec:	54 f0       	brlt	.+20     	; 0x302 <main+0x158>
			MD2_DIR_SET();
 2ee:	da 01       	movw	r26, r20
 2f0:	15 96       	adiw	r26, 0x05	; 5
 2f2:	bc 92       	st	X, r11
			STATUS1_CLR();
 2f4:	d9 01       	movw	r26, r18
 2f6:	16 96       	adiw	r26, 0x06	; 6
 2f8:	cc 92       	st	X, r12
 2fa:	16 97       	sbiw	r26, 0x06	; 6
			STATUS2_SET();
 2fc:	15 96       	adiw	r26, 0x05	; 5
 2fe:	dc 92       	st	X, r13
 300:	09 c0       	rjmp	.+18     	; 0x314 <main+0x16a>
		}
		else {
			MD2_DIR_CLR();
 302:	da 01       	movw	r26, r20
 304:	16 96       	adiw	r26, 0x06	; 6
 306:	bc 92       	st	X, r11
			STATUS1_SET();
 308:	d9 01       	movw	r26, r18
 30a:	15 96       	adiw	r26, 0x05	; 5
 30c:	cc 92       	st	X, r12
 30e:	15 97       	sbiw	r26, 0x05	; 5
			STATUS2_CLR();
 310:	16 96       	adiw	r26, 0x06	; 6
 312:	dc 92       	st	X, r13
		}
		if(swap > 500){
 314:	85 3f       	cpi	r24, 0xF5	; 245
 316:	b1 e0       	ldi	r27, 0x01	; 1
 318:	9b 07       	cpc	r25, r27
 31a:	14 f0       	brlt	.+4      	; 0x320 <main+0x176>
			swap = 0;
 31c:	80 e0       	ldi	r24, 0x00	; 0
 31e:	90 e0       	ldi	r25, 0x00	; 0
		}
		
		if((PORTA.IN & (1 << PIN0_bp)) == 0){
 320:	db 01       	movw	r26, r22
 322:	18 96       	adiw	r26, 0x08	; 8
 324:	1c 91       	ld	r17, X
 326:	10 fd       	sbrc	r17, 0
 328:	04 c0       	rjmp	.+8      	; 0x332 <main+0x188>
			ERROR_SET();
 32a:	d9 01       	movw	r26, r18
 32c:	15 96       	adiw	r26, 0x05	; 5
 32e:	ec 92       	st	X, r14
 330:	bc cf       	rjmp	.-136    	; 0x2aa <main+0x100>
		}
		else {
			ERROR_CLR();
 332:	d9 01       	movw	r26, r18
 334:	16 96       	adiw	r26, 0x06	; 6
 336:	ec 92       	st	X, r14
 338:	b8 cf       	rjmp	.-144    	; 0x2aa <main+0x100>

0000033a <_exit>:
 33a:	f8 94       	cli

0000033c <__stop_program>:
 33c:	ff cf       	rjmp	.-2      	; 0x33c <__stop_program>
